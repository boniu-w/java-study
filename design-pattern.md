# 1. 策略模式

策略模式是一种行为型设计模式，它定义了一系列算法，将每个算法封装起来并使它们之间可以互换。策略模式让算法独立于使用它的客户端，从而可以方便地修改、扩展或替换算法，而不会对客户端产生影响。

策略模式适用于以下场景：

1. 当你需要在运行时选择算法的时候，例如一个排序程序可以让用户选择不同的排序算法。
2. 当你有多个相关的类，它们只有一些行为有所不同的时候，例如一个图形绘制程序可以使用不同的绘制算法来绘制不同的图形。
3. 当你需要避免使用大量的条件语句来实现不同的行为的时候，例如一个优惠券系统可以使用不同的策略来计算不同的优惠金额，而不需要使用大量的if-else语句来处理。
4. 当你需要对算法进行单元测试时，策略模式可以方便地对每个算法进行独立的测试。

总之，当你需要在运行时选择不同的算法，并且希望这些算法可以独立地变化和扩展时，可以考虑使用策略模式。



# 2. 工厂模式

工厂模式是一种创建型设计模式，它提供了一种将对象的创建与使用分离的方式。工厂模式通过定义一个工厂类来创建对象，而不是在客户端代码中直接实例化对象，从而使得客户端代码更加灵活和可维护。

工厂模式适用于以下场景：

1. 当一个类不知道它所必须创建的对象的类的时候，例如一个日历程序需要创建不同类型的日历对象，但是具体的日历类型在运行时才能确定。
2. 当一个类希望由它的子类来指定所创建的对象的时候，例如一个游戏中的敌人类可以由不同类型的子类来指定创建的敌人类型。
3. 当一个类希望将对象的创建工作委托给多个帮助类中的某一个，而不是直接在自己内部创建对象时，例如一个日志记录器类可以委托给不同的日志记录策略类来创建具体的日志记录器对象。

总之，当你需要在代码中创建对象时，可以考虑使用工厂模式，它可以使得你的代码更加灵活和可维护，并且可以将对象的创建和使用分离开来。

# 3. observer 观察者模式

观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，它的所有依赖者都会自动收到通知并且更新自己的状态。

观察者模式适用于以下场景：

1. 当一个对象的改变需要同时改变其他对象的时候，例如当一个商品的价格发生变化时，需要通知所有的购买者。
2. 当一个对象的改变需要同时改变一组对象的时候，例如当一个博客文章被更新时，需要通知所有订阅该博客的用户。
3. 当一个对象的改变需要通知其他对象，但是你并不知道这些对象是谁的时候，例如一个用户对多个群组都进行了订阅，需要通知所有相关的群组。
4. 当一个对象的改变需要改变另一个对象，但是另一个对象又依赖于其他对象时，例如一个股票价格的变化会影响到一个投资组合的价值，而这个投资组合又依赖于多个股票。

总之，当你需要建立一种对象间的松耦合关系，并且希望一个对象的改变能够通知其他对象的时候，可以考虑使用观察者模式。



# 4. 装饰器模式

装饰器模式是一种结构型设计模式，它允许在运行时为对象添加额外的行为，而不需要修改原始对象的结构。装饰器模式通过将对象包装在一个或多个装饰器中来实现这一目的，从而允许客户端在运行时动态地添加或删除行为。

装饰器模式适用于以下场景：

1. 当你需要在运行时动态地为对象添加行为时，例如添加额外的验证、日志记录、缓存等。
2. 当你需要在不影响其他对象的情况下，透明地修改对象的功能时，例如为一个现有的类添加新的方法，但又不能修改它的源代码。



# 5. 适配器模式

适配器模式是一种常用的设计模式，它的主要作用是将一个类的接口转换成客户端所期望的另一种接口，从而使原本由于接口不兼容而不能一起工作的类可以在一起工作。

适配器模式的应用非常广泛，下面列举几个典型的应用场景：

1. 软件系统升级时，新系统需要与旧系统的接口进行兼容，就可以使用适配器模式来实现兼容。
2. 在开发中，如果需要重用一些现有的类，但是这些类的接口与当前的系统不兼容，也可以使用适配器模式来实现接口兼容。
3. 在开发中，可能需要使用一些第三方库或者服务，而这些库或服务的接口与我们的系统接口不一致，这时候可以使用适配器模式来实现接口转换。
4. 在设计模式中，常常使用适配器模式将一些设计模式的接口进行兼容，例如迭代器模式和组合模式等。

总之，适配器模式是一种非常常用的设计模式，它可以帮助我们解决接口不兼容的问题，使得不同的类可以协同工作，提高系统的灵活性和扩展性。