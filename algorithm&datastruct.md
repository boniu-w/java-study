# 1. 红黑树

红黑树之所以被称为红黑树而不是红蓝树，是因为历史原因和其设计的内在逻辑。这个命名并不是随意的，而是由它的特性和性质所决定的。

1. **颜色对比**：红黑树中使用了红色和黑色两种颜色来表示节点，这两种颜色在视觉上有很好的对比，使得树的结构更加清晰易懂。
2. **颜色含义**：红色通常表示“危险”、“不稳定”，而黑色则表示“稳定”、“安全”。在红黑树中，红色节点用于调整树的平衡，使得树保持稳定状态，而黑色节点则用于维护树的黑高性质，使得树的高度不会过高。
3. **历史原因**：红黑树最初由鲁道夫·贝尔（Rudolf Bayer）和艾伯特·伍尔夫（Edward M. McCreight）在1972年提出，后来由雷蒙德·希尼（Raymond L. Hinds）和罗伯特·塞奇威克（Robert Sedgewick）在1978年进一步完善。红黑树这个名称可能是由希尼和塞奇威克提出的，但确切的起源并不清楚。

总的来说，红黑树之所以被称为红黑树而不是红蓝树，是因为红色和黑色这两种颜色在表示节点时更加直观和合适，并且符合红黑树的设计原则和性质。



--  红黑树的性质: 

节点颜色：每个节点被标记为红色或黑色。
根节点性质：根节点是黑色的。
叶子节点性质：叶子节点（NIL节点，空节点）是黑色的。
红色节点性质：如果一个红色节点存在，那么它的子节点必须是黑色的。
黑高性质：从任一节点到其每个叶子节点的简单路径上，黑色节点的数量相同。
这些性质保证了红黑树的平衡，使得在最坏情况下，红黑树的插入、删除和查找操作的时间复杂度都能保持在对数时间范围内。



红黑树中红色节点和黑色节点具有一些特定的性质，这些性质有助于维持红黑树的平衡状态：

1. **根节点性质**：根节点必须是黑色的。这是为了确保树的黑高性质成立。
2. **红色节点性质**：如果一个节点是红色的，那么它的子节点必须是黑色的。这一性质确保了没有两个相邻的红色节点。
3. **黑高性质**：从根节点到任意叶子节点的路径上，黑色节点的数量必须相同。这一性质保证了树的平衡性。
4. **叶子节点性质**：叶子节点（NIL节点，空节点）都是黑色的。这样可以使得在计算黑高时，叶子节点不会被计算进去。
5. **红黑树的插入和删除性质**：在插入或删除节点后，需要确保仍然满足上述性质，并通过旋转和重新着色来维持平衡。

1. 每个节点要么是黑色, 要么是红色。
2. 根节点是黑色。 ---> 硬性规定, 无法推导出这个结论
3. 每个叶子节点(Nil)是黑色。 ---> 叶子节点都是黑色虚节点(color=black;value=None)
4. 每个红色节点的两个子节点一定都是黑色(父节点也是黑色)。
5. 任意一个节点到每个叶子节点的路径都包含相同数量的黑节点。 (红黑树不是完美平衡, 但是黑色完美平衡)

--  红黑树的规律（由五大性质推导出）
**结论：**性质4 5作为约束可以保证任意节点到每个叶子节点路径最长不会超过最短路径的2倍

**原因：**最极端情况下：出现最短路径时, 这条路径必然都是黑节点; 出现最长路径时, 这条路径必然是红黑节点相间构成, 此时路径上红节点数量=黑节点数量; 再结合性质5, 极端情况下最长路径也仅仅是最短路径的两倍。

--  红黑树的插入操作

思路：每次插入之后要操作保持红黑树的性质。1. 查找插入的位置 2.插入后自平衡

自平衡的4种情况：(设curr为当前节点)







# 2. 归并排序

```java
package wg.application.algorithm.chatgpt;

import java.util.Arrays;

/************************************************************************
 * @author: wg
 * @description: 归并算法(chatGpt)
 * 归并算法（Merge Sort）是分治算法的一种。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，
 * 再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
 * @params:
 * @return:
 * @createTime: 12:49  2023/2/8
 * @updateTime: 12:49  2023/2/8
 ************************************************************************/
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {2, 1, 6, 5, 9, 8, 2020, 199};
        sort(arr);
        System.out.println("Arrays.toString(arr) = " + Arrays.toString(arr));
    }

    public static void sort(int[] arr) {
        int[] temp = new int[arr.length];
        sort(arr, 0, arr.length - 1, temp);
    }

    private static void sort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;
            sort(arr, left, mid, temp);
            sort(arr, mid + 1, right, temp);
            merge(arr, left, mid, right, temp);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int t = 0;
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[t++] = arr[i++];
            } else {
                temp[t++] = arr[j++];
            }
        }
        while (i <= mid) {
            temp[t++] = arr[i++];
        }
        while (j <= right) {
            temp[t++] = arr[j++];
        }
        t = 0;
        while (left <= right) {
            arr[left++] = temp[t++];
        }
    }
}

```



sort(int[] arr, int left, int right, int[] temp) 方法是归并排序算法的核心部分，它接受一个整型数组 arr，以及两个整数 left 和 right，用于指定排序的范围，同时使用一个临时数组 temp 来辅助排序。下面我会逐步详细分析这个方法的实现：

参数解释：

arr: 待排序的整型数组。
left: 表示当前排序范围的左边界，初始值为子数组的起始索引。
right: 表示当前排序范围的右边界，初始值为子数组的结束索引。
temp: 用于临时存储排序过程中的数据的辅助数组。
方法逻辑：

方法首先检查当前排序范围是否有效，即 left < right，如果不是，则表示当前范围为空或只有一个元素，无需排序，直接返回。
接下来，方法计算当前范围的中间索引 mid，以将当前数组分为两个子数组进行递归排序。
递归调用 sort 方法，分别对左右两个子数组进行排序。
最后，调用 merge 方法将排好序的左右两个子数组合并成一个有序数组。
关键步骤分析：

int mid = (left + right) / 2;：计算当前排序范围的中间索引。
sort(arr, left, mid, temp); 和 sort(arr, mid + 1, right, temp);：递归地对左右两个子数组进行排序。
merge(arr, left, mid, right, temp);：调用 merge 方法将排好序的左右两个子数组合并。
递归结束条件：

当 left 不小于 right 时，表示当前排序范围为空或只有一个元素，无需继续分解和排序，直接返回。
时间复杂度：

归并排序的时间复杂度为 O(nlogn)，其中 n 是待排序数组的长度。这是因为每次将数组分成两半，递归地对子数组进行排序，并最终合并这些子数组，时间复杂度主要由合并操作决定。
空间复杂度：

归并排序的空间复杂度取决于辅助数组 temp 的空间占用，为 O(n)。因为在归并排序的过程中需要额外使用一个大小与原数组相同的辅助数组来存储临时数据。
总的来说，sort(int[] arr, int left, int right, int[] temp) 方法通过递归地将数组分解为更小的子数组，然后合并这些子数组，最终实现了对整个数组的排序



让我们详细分析 `merge(int[] arr, int left, int mid, int right, int[] temp)` 方法，这是归并排序算法中的合并步骤，用于将两个已经排好序的子数组合并成一个有序数组。

1. **参数解释**：
   - `arr`: 待合并的整型数组。
   - `left`: 表示左侧子数组的起始索引。
   - `mid`: 表示左侧子数组的结束索引，同时也是右侧子数组的起始索引。
   - `right`: 表示右侧子数组的结束索引。
   - `temp`: 用于临时存储合并过程中的数据的辅助数组。
2. **方法逻辑**：
   - 方法首先创建了几个变量来辅助合并过程，如 `i` 用于遍历左侧子数组，`j` 用于遍历右侧子数组，`t` 用于遍历临时数组 `temp`。
   - 方法使用了三个循环，第一个循环用于比较左右两个子数组的元素并按顺序放入临时数组中，第二和第三个循环用于将剩余的元素放入临时数组中（因为左右两个子数组长度可能不同）。
   - 最后，通过将临时数组的内容复制回原数组 `arr`，完成合并过程。
3. **关键步骤分析**：
   - `int i = left; int j = mid + 1; int t = 0;`：初始化变量，`i` 指向左侧子数组的起始位置，`j` 指向右侧子数组的起始位置，`t` 为临时数组的索引。
   - `while (i <= mid && j <= right)`：比较左右两个子数组的元素，按顺序放入临时数组中。
   - `while (i <= mid)` 和 `while (j <= right)`：将左右两个子数组中剩余的元素放入临时数组中。
   - `while (left <= right)`：将临时数组中的元素复制回原数组 `arr`。
4. **时间复杂度**：
   - 合并操作的时间复杂度为 O(n)，其中 n 是待合并的两个子数组的总长度。
5. **空间复杂度**：
   - 合并操作的空间复杂度为 O(n)，主要是由临时数组 `temp` 的空间占用决定的。

总的来说，`merge(int[] arr, int left, int mid, int right, int[] temp)` 方法实现了将两个已排好序的子数组合并成一个有序数组的功能，是归并排序算法中的关键步骤之一。



在归并排序中，当执行 `sort(arr, left, mid, temp);` 后，会对左侧子数组进行排序，直到左侧子数组的范围缩小到只有一个元素或为空时，才会结束递归。然后程序会继续执行 `sort(arr, mid + 1, right, temp);` 这一步，对右侧子数组进行排序。

程序走到 `sort(arr, mid + 1, right, temp);` 这一步的时机是在对左侧子数组排序完成之后。因为归并排序是一个分治算法，它的核心思想是将数组不断分解为更小的子数组，直到每个子数组只有一个元素或为空，然后再将这些子数组合并成一个有序数组。因此，在对左侧子数组进行排序后，程序会继续对右侧子数组进行排序，直到所有子数组都被排序完成，整个数组变得有序。



# 3. 贪心法

不考虑整体最优, 只考虑局部最优, 这种局部最优并不能保证能达到全局最优, 但通常能达到较好的近似最优解

贪心算法的步骤通常包括：

1. **选择策略**：确定每一步选择的策略或规则，使得该选择在当前状态下是局部最优的。
2. **判断可行性**：对每一步的选择进行判断，确保选择不会破坏问题的约束条件或限制条件。
3. **解决子问题**：在做出选择后，将原问题转化为一个规模更小的子问题，然后递归或迭代地解决子问题。
4. **构建解集**：将每一步的选择添加到解集中，并最终得到全局最优解。

贪心算法常见的应用包括：

- 最小生成树（如Prim算法、Kruskal算法）
- 单源最短路径（如Dijkstra算法）
- 背包问题的近似解（如分数背包问题）
- 调度问题（如任务调度）
- 区间覆盖问题（如最小区间覆盖）

需要注意的是，并非所有问题都适合贪心算法求解，因为贪心算法可能会导致局部最优解与全局最优解不一致。因此，在应用贪心算法时，需要仔细分析问题的特性，确保问题满足贪心选择性质和最优子结构性质。